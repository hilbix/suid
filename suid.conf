# Sample /etc/suid.conf
#
# This Works is placed under the terms of the Copyright Less License,
# see file COPYRIGHT.CLL.  USE AT OWN RISK, ABSOLUTELY NO WARRANTY.
#
# Empty lines and lines starting with # are ignored
# All other lines mostly conform to /etc/passwd format:
#
# command:pw:user:group:minmax:dir:/path/to/binary:args..
#
# For escaping binary/args which contain ':' see below
#
# "command" must be given to "suid" as first argument.
# "pw" contains a comma separated list of option entries, see below.
# "user" and "group" are:
# - "" (empty):	Effective UID/GID is used
# - "*":	UID/GID of the calling user is used
# - "=":	GID from the USER entry is used
# - "num":	UID/GID
# - "name":	Username/Groupname is used
# "minmax" are flags:
# - "C":	argv[] is given suid cmd (default: command in .conf)
# - "D":	debugging to stderr
# - "I":	insecure operation (do not check exec'd file permission)
# - "F":	argv[0] is file name of real exec'd file
# - "R":	argv[0] is real path of real exec'd file
# - "S":	disable shellshock prevention (allows env starting with '() {')
# - "!":	this entry is an option, see below
# - "num":	minimum number of args from commandline, optional, default 0
# - "-num":	maximum number of args, if "num" missing unlimited, defaults to min
# "dir":	optional directory, if not set directory is not changed
# - "." denotes the HOME of the user to switch to
# - if "/./" is in the path, it does a 'chroot()' into the given path
# optional list of modifiers like "suid" or "esuid", see below.
# "/path/to/binary": command to execute
# ":args..": optional list of preset arguments, separated by ':'.  Can be left away.
# Commandline arguments are added to the end of this list, if "minmax" permits.
#
# Modifiers are ":"-separated prefixes to "/path/to/binary":
# - "esuid:" to NOT switch user, instead pass chosen user etc. in euid()/egid().
# - "suid:" as before, but fake as if command would have been execed SUID via FS.
#   "esuid" and "suid" only differ on users not "root:root".
# Example: !name:pw:option:value:!flags:dir:suid:/path/to/binary:args..
#
# option entries are like normal entries, but with a leading '!' in the minmax position:
#
# !name:pw:option:value:!flags:dir:/path/to/binary:args..
#
# !name: The name of the option, which has '!' appended to the name
# pw: comma separated list of additional option entries
# user: a name of an option
# value: the value of an option
# flags: must start with '!', can follow with
# - "D":	debugging to stderr
# - "S":	disable shellshock prevention (allows env starting with '() {')
# "dir":	optional directory, if not set directory is not changed
# "/path/to/binary": optional command to execute
# ":args..": optional is list of arguments, separated by ':'
#
# 0) For a list of all options, run 'suid' without argument.
# 1) If an option is present, it takes effect, before the command runs.
# 2) If the option fails, the whole process is aborted.
# 3) The option has stdin and stdout connected to suid's stderr (usually the terminal).
# 4) stderr is connected to a pipe and the output is inspected by "suid".
# 5) if this output contains unexpected data, the option fails, too.
#
# If the option fails, 'suid' outputs something to stderr,
# does not run the intended command and exits with error code 126.
#
# All existing environment variables are prefixed with "SUID_".
# "TERM" is preserved, and a default "PATH" is set.
# "SUIDUID" and "SUIDGID" are set to the original UID/GID of the caller.
# "SUIDPWD" is set to the original current directory.
#
# Escapes:
#
# There are two (only two) escape sequences (literally) understood:
#
# '\\:' which takes precedence and is removed.
# '\:' which is escapes a ':'.
# Hence you can unambiguously escape ':' in arguments to '\\:\:'.
#
# Intention is to allow forward- and backward-scanning for escapes,
# as well to unambiguously create an escaped command in bash easily:
# cmd=(command line args); printf ':%s\\\\:' "${cmd[@]//:/\\\\:\\:}"
# as long as there is no linefeed anywhere.  With linefeeds do:
# printf -v esc1 ' %q' "${cmd[@]}"; printf ":bash:-c:%s" "${esc1//:/\\\\:\\:}"
#
# Examples:
# 'ab' can be written as 'a\\:b' or '\\:a\\:b\\:' or similar.
# 'a:b' must be 'a\:b' at least and should be 'a\\:\:b'.
# 'a\b' can be 'a\b' but 'a\\\:b' is ok as well.
# 'a\:b' must be 'a\\\:\:b' as 'a\\:b' becomes 'ab'.  Compare:
# 'a\\:b' must be 'a\\\\:\:b', so adding a '\' is possible.

#echo::::D-:/:/bin/echo:--
#dmesg:::::/:/bin/dmesg
#dmesgrw:::::/:/bin/dmesg:-rw
